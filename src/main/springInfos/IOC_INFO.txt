Было: класс сам создаёт зависимости
IOC: класс отдельно и зависимости отдельно, взаимодействие происходит через интерфейс

Что такое инверсия контроля в Spring Framework? Это процесс управления взаимодействием объектов

По сути Spring Framework представляет собой просто контейнер внедрения зависимостей,
с несколькими удобными слоями (например: доступ к базе данных, прокси, аспектно-ориентированное программирование,
 RPC, веб-инфраструктура MVC).  https://habr.com/ru/articles/490586/

 Внедрение зависимостей в Спринге (и не только): 1. конструктор 2. сеттер 3. поле (рефлексия)
 Через сеттер - метод не обязательно будет называться set...
 ! Документация Spring советует использовать внедрение через конструктор

 ИК - вынесение процесса создание зависимости вне объекта
 ДИ - само внедрение зависимости (реализация ИК)  DI для Spring это и есть инициализация полей бинов другими бинами (зависимостями).

org.springframework:spring-context -> AnnotationConfigApplicationContext

@Component - из этого класса нужно создать бин. всё, что внедряется, должно быть компонентом.
@Autowired связываем, чтобы установить зависимость - Для автосвязывания по типу или по имени используется аннотация @Autowired

@Primary - если 2 реализации бина, кого выбрать
@Qualifier

Спринг контейнер = менеджер бинов: ядро спринга, позволяет создавать, управлять и конфигурировать объекты
Объект под управлением контейнера = бин (Класс + инструкция +после контейнера = бин)

ApplicationContext() - способ создания контейнера

3 способа создания метаданных:
1. xml, <Bean></Bean> context = new ClassPathApplicationContext (applicationContext.xml)  пом: спринг-бинс
2. Спец джава конфиг class AppConfig с аннотацией @Configuration + указаны бины с анн.@Bean  пом: спринг-контекст
context = new AnnotationConfigApplicationContext(AppConfig.class) Без аннотаций над бинами.
3. Аннотации @Component, @Autowired, @Primary, ... + AnnotationConfigApplicationContext из 2.

AnnotationConfigApplicationContext и ClassPathApplicationContext наследуют Интерфейс ApplicationContext,
Интерфейс ApplicationContext наследует Интерфейс BeanFactory
== BeanFactory: реализация бинов, фабрика бинов, xml НЕТ: аннотаций и событий. Модуль org.springspringframework:spring-beans
== ApplicationContext: BeanFactory + аннотации + события + property файлы + i18n -интернационализация, неск языков в приложении.
Модуль org.springspringframework:context

Как создать Spring контейнер - Создавая объект одной из реализаций класса ApplicationContext и настраивая его соответствующим образом
Чтобы получить бин нужно вызвать метод getBean(). В качестве параметра можно указать класс бина, или имя бина.

Если создавать объекты через BeanFactory, то можно сделать бином любой ссылочный тип, например, строки или интеджер

BeanDefinitions -Класс, который определяет структуру бина.
BeanDefinitions создаются из метаданных, из BeanDefinitions потом создаются сами бины.
Bean - объекты, которые могут быть использованы в качестве зависимостей других объектов.

Области видимости бинов
singleton - Возвращает один и тот же экземпляр бина на каждый запрос контейнера Spring IoC (по умолчанию).
prototype - Создает и возвращает новый экземпляр бина на каждый запрос. //старый экз не хранится
+ кастомный (наследоваться от скоуп)
request - Создает и возвращает экземпляр бина на каждый HTTP запрос*.
session - Создает и возвращает экземпляр бина для каждой HTTP сессии*.
global-session - Создает и возвращает экземпляр бина для глобальной HTTP сессии*.

Допустим ситуацию, когда в singleton-компонент внедряется зависимость со скоупом prototype – когда будет создан её объект?
В аннотации @Scope кроме самого scopeName доступен второй параметр – proxyMode.
По умолчанию его значение NO – прокси не создается. Но если указать INTERFACES или TARGET_CLASS, то под @Autowired будет внедряться не сам объект, а сгенерированный фреймворком прокси. И когда проксируемый бин имеет скоуп prototype, то объект внутри прокси будет пересоздаваться при каждом обращении.

Мы можем создать объект одного из классов-реализаций интерфейса BeanDefinition
Мы можем использовать setInitMethodName() и setDestroyMethodName() методы, и передать в них имя метода

Жизн цикл бинов:


Из каких частей состоит Spring Framework?

Основной контейнер - предоставляет основной функционал Spring. Главным компонентом контейнера является BeanFactory - реализация паттерна Фабрика. BeanFactory позволяет разделить конфигурацию приложения и информацию о зависимостях от кода.
Spring context - конфигурационный файл, который предоставляет информация об окружающей среде для Spring. Сюда входят такие enterprise-сервисы, как JNDI, EJB, интернационализация, валиадция и т.п.
Spring AOP - отвечает за интеграцию аспектно-ориентированного программирования во фреймворк. Spring AOP обеспечивает сервис управления транзакциями для Spring-приложения.
Spring DAO - абстрактный уровень Spring JDBC DAO предоставляет иерархию исключений и множество сообщений об ошибках для разных БД. Эта иерархия упрощает обработку исключений и значительно уменьшает количество кода, которое вам нужно было бы написать для таких операций, как, например, открытие и закрытие соединения.
Spring ORM - отвечает за интеграцию Spring и таких популярных ORM-фреймворков, как Hibernate, iBatis и JDO.
Spring Web module - классы, которые помогают упростить разработку Web (авторизация, доступ к бинам Spring-а из web).
Spring MVC framework - реализация паттерна MVC для построения Web-приложений.